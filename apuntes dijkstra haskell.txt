GRAFOS PONDERADOS

Gp = (A -> N, V-> P(v))

Ejemplo:
Gid : V -> P(N)
Gid: \v -> [v]

funcion de costo:
Cv: A -> N
Cv (o, d) = o --El costo es el origen

Gpidcv : (A -> N, V -> P(N))
Gpidcv = (Cv, Gid)

costoCamino: (A -> N, V -> P(N)) -> [V] -> N
costoCamino Gp [] 
costoCamino gp [v] = 0
costoCamino (c,g) (v1:v2:vs) = (c(v1,v2) + costoCamino (c, g) (v2:vs)



DIJKSTRA

costos: V -> N


dijsktra :: (A -> N, V -> Conj V) -> V -> V -> N
dijsktra gp o d = (dijsktra' gp o visit(costos o)) d 

visit es una funcion que me retorna si un vertice fue visitado
costos es una funcion de costos que representa el vector de costos

dijsktra' :: (A -> N, V -> Conj V) -> V -> (V -> Bool) -> (V -> N) -> (V -> N)
dijsktra' (c, g) v vs cs = dijsktra' (c, g) funcionVerticeMenorCosto (visit v vs) (costosA c v (g v) cs)

costos :: V -> (V -> N)
costos o = \v -> case v == o of {
	True -> 0;
	False -> 99999 -- numero muy grande representa el infinito
}

visit :: V -> Bool
visit = \v.False
visitV :: V -> (V -> Bool) -> (V -> Bool)
visitV v vs = \v' -> v == v' || (vs v')

costosA :: (A -> N) -> V -> [V] ->(V -> N) -> (V -> N)
costosA c v [] cs = cs
costosA c v (a:ady) cs = \a' -> case a == a' of {
	False -> cs;
	True -> case (cs a > c v + c(v, a)) of {
		False -> cs a;
		True -> cs v + c(v, a)
	}
}



--OTRA VERSION
dijkstra :: V -> V -> GP -> Int
dijkstra origen destino gp = fromMaybe infinito (lookup destino (dijkstra' origen gp))

--calcula las distancias mínimas desde un vértice origen a todos los demás vértices en un grafo ponderado.
dijkstra' :: V -> GP -> [(V, Int)]
dijkstra' origen gp@((g, n), c) = dijkstraRec [origen] [] (inicializarDistancias (vertices2 (g, n)) origen)
  where
    inicializarDistancias :: [V] -> V -> [(V, Int)]
    inicializarDistancias vs origen = [(v, if v == origen then 0 else infinito) | v <- vs]

    dijkstraRec :: [V] -> [V] -> [(V, Int)] -> [(V, Int)]
    dijkstraRec [] _ distancias = distancias
    dijkstraRec (v:vs) visitados distancias =
        let vecinos = g v
            distV = fromJust (lookup v distancias)
            distancias' = foldl (actualizarDistancia v distV) distancias vecinos
            visitados' = v : visitados
            (v', _) = minimoNoVisitado distancias' visitados'
        in dijkstraRec (delete v' (vertices2 (g, n)) ++ vs) visitados' distancias'

    actualizarDistancia :: V -> Int -> [(V, Int)] -> V -> [(V, Int)]
    actualizarDistancia v distV distancias vecino =
        let alt = distV + fromIntegral (c (v, vecino))
            distVecino = fromJust (lookup vecino distancias)
        in if alt < distVecino
           then (vecino, alt) : delete (vecino, distVecino) distancias
           else distancias

    minimoNoVisitado :: [(V, Int)] -> [V] -> (V, Int)
    minimoNoVisitado distancias visitados =
        let noVisitados = filter (\(v, _) -> v `notElem` visitados) distancias
        in foldl1 (\acc x -> if snd x < snd acc then x else acc) noVisitados

--rastrea los caminos más cortos en términos de las aristas que se recorren
dijkstra'' :: V -> GP -> [(V, V)]
dijkstra'' origen gp@((g, n), c) = dijkstraRec [origen] [] (inicializarDistancias (vertices2 (g, n)) origen) []
  where
    inicializarDistancias :: [V] -> V -> [(V, Int)]
    inicializarDistancias vs origen = [(v, if v == origen then 0 else infinito) | v <- vs]

    dijkstraRec :: [V] -> [V] -> [(V, Int)] -> [(V, V)] -> [(V, V)]
    dijkstraRec [] _ _ caminos = caminos
    dijkstraRec (v:vs) visitados distancias caminos =
        let vecinos = g v
            distV = fromJust (lookup v distancias)
            (distancias', caminos') = foldl (actualizarDistanciaYCaminos v distV) (distancias, caminos) vecinos
            visitados' = v : visitados
            (v', _) = minimoNoVisitado distancias' visitados'
        in dijkstraRec (delete v' (vertices2 (g, n)) ++ vs) visitados' distancias' caminos'

    actualizarDistanciaYCaminos :: V -> Int -> ([(V, Int)], [(V, V)]) -> V -> ([(V, Int)], [(V, V)])
    actualizarDistanciaYCaminos v distV (distancias, caminos) vecino =
        let alt = distV + fromIntegral (c (v, vecino))
            distVecino = fromJust (lookup vecino distancias)
        in if alt < distVecino
           then ((vecino, alt) : delete (vecino, distVecino) distancias, (vecino, v) : caminos)
           else (distancias, caminos)

    minimoNoVisitado :: [(V, Int)] -> [V] -> (V, Int)
    minimoNoVisitado distancias visitados =
        let noVisitados = filter (\(v, _) -> v `notElem` visitados) distancias
        in foldl1 (\acc x -> if snd x < snd acc then x else acc) noVisitados

dijkstra''' :: V -> GP -> [(V, V, N)]
dijkstra''' origen gp@((g, n), c) = [(v, u, c (u, v)) | (v, u) <- dijkstra'' origen gp